ylab="returns", col=c("blue","orange"), lwd=c(2,2))
abline(h=0)
legend(x="bottomright",legend=c("S&P 500","SBUX"),
lwd=c(2,2),col=c("blue","orange"))
plot(si.df$sp500,si.df$sbux, col="slateblue1",lwd=2, pch=16, cex=2,
main="Monthly cc returns on S&P 500 and Starbucks",
xlab="cc return on S&P 500", ylab="cc return on SBUX")
abline(h=0,v=0)
abline(a=alpha.vals["sbux"],b=beta.vals["sbux"],
col="orange", lwd=3)
colnames(si.df)
msft.fit = lm(msft~sp500,data=si.df)
class(msft.fit)
names(msft.fit)
msft.fit$coef
msft.fit
# summary method - gives SE values, t-stats etc
summary(msft.fit)
# extractor functions
coef(msft.fit)
residuals(msft.fit)[1:5]
fitted(msft.fit)[1:5]
msft.summary = summary(msft.fit)
names(msft.summary)
msft.summary$coef
msft.summary$r.squared
msft.fit
names(msft.fit)
plot(si.df$sp500,si.df$msft,col="slateblue1", pch=16, cex=2,
main="Estimated SI model for Microsoft",
ylab="msft",xlab="sp500")
# plot line with intercept=least squares intercept,
# slope=least squares slope
abline(h=0,v=0)
abline(msft.fit, col="orange", lwd=3)
layout(matrix(c(1,1,2,2), 2, 2, byrow=T))
layout.show(2)
ts.plot(si.df$msft, main="actual and fitted",
col="blue", lwd=2, ylab="returns")
abline(h=0)
lines(fitted(msft.fit), col="orange", lwd=3)
legend(x="bottomleft",legend=c("fitted","actual"),
lwd=c(2,2),col=c("orange","blue"))
ts.plot(residuals(msft.fit),main="residuals",
ylab="returns", lwd=3, col="green")
abline(h=0)
ehat = residuals(msft.fit)
par(mfrow=c(2,2))
hist(ehat, xlab="residuals",ylab="frequency",
main="Residuals from SI model for MSFT",
col="slateblue1")
boxplot(ehat,outchar=T, col="slateblue1")
plot(density(ehat),type="l",xlab="residual",
ylab="density", col="slateblue1", main="smoothed density")
qqnorm(ehat, col="slateblue1")
qqline(ehat)
par(mfrow=c(1,1))
par(mfrow=c(2,1))
plot(zoo(ehat, as.Date(names(ehat))),main="MSFT residuals", ylab="ehat")
abline(h=0)
acf(ehat, main="ACF of MSFT residuals", lwd=3)
par(mfrow=c(1,1))
?ac
?acf
sbux.fit = lm(sbux~sp500,data=si.df)
nord.fit = lm(nord~sp500,data=si.df)
boeing.fit = lm(boeing~sp500,data=si.df)
port = (si.df$msft + si.df$sbux + si.df$nord + si.df$boeing)/4
si.df$port = port
colnames(si.df)
port.fit = lm(port~sp500,data=si.df)
summary(port.fit)
plot(si.df$sp500,si.df$port,main="SI model for 4 Asset Portfolio",
col="slateblue", pch=16, cex=2)	# create scatterplot
abline(port.fit, col="orange", lwd=3)									# add regression line
abline(h=0,v=0)
coef(sbux.fit)
sbux.beta = coef(sbux.fit)[2]
msft.beta = coef(msft.fit)[2]
nord.beta = coef(nord.fit)[2]
boeing.beta = coef(boeing.fit)[2]
beta.vec = c(sbux.beta,msft.beta,nord.beta,boeing.beta)
names(beta.vec) = c("SBUX","MSFT","NORD","BOEING")
beta.vec
sig2.sp500 = var(si.df$sp500)
sig2.sp500
cov.market = sig2.sp500*(beta.vec%*%t(beta.vec))
cov.market
residuals(sbux.fit)
sig2e.sbux = var(residuals(sbux.fit))
sig2e.msft = var(residuals(msft.fit))
sig2e.nord = var(residuals(nord.fit))
sig2e.boeing = var(residuals(boeing.fit))
D.mat = diag(c(sig2e.sbux,sig2e.msft,sig2e.nord,sig2e.boeing))
D.mat
cov.si = cov.market + D.mat
cov.si
cov.hat = var(si.df[,2:5])
cov.hat
cov.si - cov.hat
?cov2cor
cor.hat = cor(si.df[,2:5])
dimnames(cor.si) = dimnames(cor.hat)
cor.si = cov2cor(cov.si)
cor.hat = cor(si.df[,2:5])
dimnames(cor.si) = dimnames(cor.hat)
cor.si
cor.hat
cor.si - cor.hat
# compute rolling betas - user PerformanceAnalytics functions
chart.RollingRegression(si.z[,"msft",drop=F], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["msft"], lwd=2, col="red")
library(PerformanceAnalytics)
chart.RollingRegression(si.z[,"msft",drop=F], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["msft"], lwd=2, col="red")
chart.RollingRegression(si.z[,"sbux",drop=F], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["sbux"], lwd=2, col="red")
chart.RollingRegression(si.z[,"nord",drop=F], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["nord"], lwd=2, col="red")
chart.RollingRegression(si.z[,"boeing",drop=F], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["boeing"], lwd=2, col="red")
?drop
chart.RollingRegression(si.z[,"boeing",drop=T], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["boeing"], lwd=2, col="red")
chart.RollingRegression(si.z[,"boeing",drop=T], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["boeing"], lwd=2, col="red")
chart.RollingRegression(si.z[,"boeing",drop=F], si.z[,"sp500",drop=F], width=24)
abline(h=beta.vals["boeing"], lwd=2, col="red")
chart.RollingRegression(si.z[,"boeing",drop=T], si.z[,"sp500",drop=T], width=24)
?RollingRegression
?chart.RollingRegression
0.43*12
sqrt(12)*5.59
(0.43-0.08)*12/(sqrt(12)*5.59)
12*0.49
sqrt(12)*2.90
(0.49-0.08)*12/(sqrt(12)*2.9)
12*1.28
sqrt(12)*8.45
(1.28-0.08)*12/(sqrt(12)*8.45)
muhat = c(0.0043, 0.0049, 0.0128)
names(muhat) = c('vpacx', 'vbltx', 'veiex')
muhat
rf = (0.0008)
sighat = c(0.0559, 0.029, 0.0845)
names(sighat) = names(muhat)
sig2hat = sighat^2
sig2hat
sighat
sigma.mat = diag(sighat)
sigma2.mat = diag(sig2hat)
sigma.mat
sigma2.mat
colnames(sigma.hat) = names(muhat)
rownames(sigma.hat) = names(muhat)
colnames(sigma.mat) = names(muhat)
rownames(sigma.mat) = names(muhat)
sigma.mat
colnames(sigma2.mat) = names(muhat)
rownames(sigma2.mat) = names(muhat)
sigma2.mat
cov.mat.inv = solve(sigma2.mat)
cov.mat.inv
rowSums(cov.mat.inv)/sum(cov.mat.inv)
tan.x = cov.mat.inv %*% (muhat - rf)
tan.x = tan.x / sum(tan.x)
tan.x
gm.x = c(0.23, 0.87, -0.1)
sum(gm.x)
gm.ret = crossprod(gm.x, muhat)
gm.ret
gm.ret = as.numeric(crossprod(gm.x, muhat))
gm.ret
gm.sd = as.numeric(sqrt(gm.x %*% sigma2.mat %*% gm.x))
gm.sd
q.val = gm.ret + gm.sd * qnorm(0.05)
q.val
100000 * (exp(q.val) - 1)
1-0.0737
1-732
1-0.732
1.5262 - qnorm(0.975)*0.1214
qnorm(0.975)
muhat
tan.x = c(-1.97, 151, 145)
names(gm.x) <- names(tan.x) <- names(muhat)
tan.x
sum(tan.x)
tan.x = c(-1.97, 1.51, 1.45)
names(gm.x) <- names(tan.x) <- names(muhat)
sum(tan.x)
betahat = c(1.00139, 0.16639, 1.5262)
crossprod(tan.x, betahat)
crossprod(gm.x, betahat)
A.top = cbind(2*sigma2.mat, muhat, 1)
a.top
A.top
A.bot = rowbind(c(muhat, 0, 0), c(rep(1,3), 0, 0))
A.bot = rbind(c(muhat, 0, 0), c(rep(1,3), 0, 0))
A.bot
A = rbind (A.top, A.bot)
A
b = c(rep(0, 3), target, 1)
target = 0.01
b = c(rep(0, 3), target, 1)
b
?solve
dim(A)
length(b)
length(A)
eff.01 = solve(A, b)
eff.01
sum(eff.01[1:3])
eff.01.x = as.numeric(eff.01.x[1:3])
eff.01.x = solve(A, b)
eff.01.x = as.numeric(eff.01.x[1:3])
names(eff.01.x) = names(muhat)
rm(eff.01)
eff.01.x
gm.ret = crossprod(gm.x, muhat)
tan.ret = crossprod(tan.x, muhat)
c(gm.ret, tan.ret)
gm.ret
solve(1)
solve(1/2)
alpha = (target.ret - tan.ret)/(gm.ret - tan.ret)
target.ret = 0.01
alpha = (target.ret - tan.ret)/(gm.ret - tan.ret)
alpha
eff.01.x = alpha*gm.x + (1-alpha)*tan.x
eff.01.x
sum(eff.01.x)
names(eff.01.x) = names(muhat)
eff.01.x
eff.01.x * 100
alpha = as.numeric((target.ret - rf)/(tan.ret - rf))
alpha
alpha = as.numeric((target.ret-tan.ret)/(rf-tan.ret)) #share of T-bills
alpha
tan.se = 0.0653
as.numeric((1-alpha)*tan.se)
cbind = (alpha, (1-alpha)*tan.x)
cbind(alpha, (1-alpha)*tan.x)
c(alpha, (1-alpha)*tan.x)
sum(c(alpha, (1-alpha)*tan.x))
?reorder
??seek
??brewer
??x_continuous
colors()
?regmatches
x <- c("A and B", "A, B and C", "A, B, C and D", "foobar")
pattern <- "[[:space:]]*(,|and)[[:space:]]"
## Match data from regexpr()
m <- regexpr(pattern, x)
m
regmatches(x, m)
regmatches(x, m, invert=T)
pattern <- " (,|and) "
m <- regexp(pattern, x)
m <- regexpr(pattern, x)
regmatches(x, m, invert=T)
pattern <- " *(,|and) "
m <- regexpr(pattern, x)
regmatches(x, m, invert=T)
m <- gregexpr(pattern, x)
regmatches(x, m, invert=T)
?recast
?reshape
library(help=reshape2)
?transform
?sample
?seq_along()
seq_along(letters[1:5])
seq_len(letters[1:5])
str(seq_len)
seq_len(23)
seq(rnorm(20))
sample(seq_along(letters[1:7]))
sample(seq_along(letters[1:7]))
sample(seq_along(letters[1:7]))
?desc
library(ggplot2)
?desc
??desc
str(diamonds)
?diamonds
library(plyr)
str(ddply)
library(reshape2)
?cast
data(airquality)
names(airquality) <- tolower(names(airquality))
head(airquality)
aqm <- melt(airquality, id=c("month", "day"), na.rm=TRUE)
head(aqm)
acast(aqm, day ~ month ~ variable)
rm(list-ls())
rm(list=ls())
data(ChickWeight)
class(ChickWeight)
head
head(ChickWeight)
names(ChickWeight) <- tolower(names(ChickWeight))
str(ChickWeight)
chick_m <- melt(ChickWeight, id=2:4, na.rm=TRUE)
str(melt)
dcast(chick_m, time ~ variable, mean)
dcast(chick_m, diet ~ variable, mean)
??xlsx
library(xlsx)
install.packages("xlsx")
load("/data/Dropbox/Data Analysis/Assignment2/samsungData.rda")
object.size(samsungData)
print(object.size(samsungData), unit='auto')
names(samsungData)
table(activity)
table(samsungData$activity)
table(samsungData$activity, useNA='ifany')
table(samsungData$subject, useNA='ifany')
class(samsungData$subject)
s <-  samsungData
rm(samsungData)
s$set <- "training"
s$set <- cut(s$subject, breaks=c(0, 22, 27, 32),
labels=c('training', 'cross validation', 'test'))
table(s$set, s$subject)
s$set <- cut(s$subject, breaks=c(0, 21, 26, 32),
labels=c('training', 'cross validation', 'test'))
table(s$set, s$subject)
table(s$set)
table(s$set)/nrow(s)
sum(complete.cases(s))
library(ElemStatLearn)
data(SAheart)
set.seed(8484)
train = sample(1:dim(SAheart)[1], size=dim(SAheart)[1]/2, replace=F)
trainSA = SAheart[train, ]
testSA = SAheart[-train, ]
str(trainSA)
logit1 <- glm(chd ~ age + alcohol + obesity + tobacco + typea + ldl, data=trainSA, family="logistic")
?family
logit1 <- glm(chd ~ age + alcohol + obesity + tobacco + typea + ldl, data=trainSA, family="binomial")
summary(logit1)
missClass = function(values, prediction) {sum(((prediction > 0.5)*1) != values)/length(values)}
missClass(trainSA$chd, predict(logit1, type='response'))
missClass(testSA$chd, predict(logit1, data=testSA, type='response'))
?predict
missClass(testSA$chd, predict(logit1, newdata=testSA, type='response'))
library(pgmm)
?sprintf
sprinttf(3, '%3d')
sprintf(3, '%3d')
sprintf('3', '%3d')
sprintf('3', '%03d')
sprintf('3', '%0d3')
sprintf('3', '%03')
sprintf('3', '%0d')
sprintf('3', '%0d3')
sprintf('%03d', 3)
sprintf('%05d', 3)
sprintf('%-5d', 3)
sprintf('%$5d', 3)
sprintf('%5d', 3)
sprintf('%t5d', 3)
sprintf('%5d', 3)
sprintf('%d', 3)
sprintf('%0d', 3)
sprintf('%03d', 3)
setwd('/data/Dropbox/Courses/Rprogramming')
file.path('hello', 'world')
setwd('Assignment1/')
a <- read.csv('specdata//001.csv')
head(a)
source('pollutantmean.R')
getMonitorMean <- function(directory, pollutant, mon){
mon.name <- paste0(sprintf('%03d', mon), '.csv')
mon.path <- file.path(directory, file.name)
dd <- read.csv(mon.path)
mean.poll <- mean(dd[, pollutant], na.rm=TRUE)
nobs.poll <- sum(!is.na(dd[, pollutant]))
return(mean.poll, nobs.poll)
}
getMonitorMean('specdata', 'sulfate', 1)
getMonitorMean <- function(directory, pollutant, mon){
mon.name <- paste0(sprintf('%03d', mon), '.csv')
mon.path <- file.path(directory, mon.name)
dd <- read.csv(mon.path)
mean.poll <- mean(dd[, pollutant], na.rm=TRUE)
nobs.poll <- sum(!is.na(dd[, pollutant]))
return(mean.poll, nobs.poll)
}
getMonitorMean('specdata', 'sulfate', 1)
getMonitorMean <- function(directory, pollutant, mon){
mon.name <- paste0(sprintf('%03d', mon), '.csv')
mon.path <- file.path(directory, mon.name)
dd <- read.csv(mon.path)
mean.poll <- mean(dd[, pollutant], na.rm=TRUE)
nobs.poll <- sum(!is.na(dd[, pollutant]))
return(c((mean.poll, nobs.poll)))
}
getMonitorMean <- function(directory, pollutant, mon){
mon.name <- paste0(sprintf('%03d', mon), '.csv')
mon.path <- file.path(directory, mon.name)
dd <- read.csv(mon.path)
mean.poll <- mean(dd[, pollutant], na.rm=TRUE)
nobs.poll <- sum(!is.na(dd[, pollutant]))
return(c(mean.poll, nobs.poll))
}
getMonitorMean('specdata', 'sulfate', 1)
mean(a$sulfate)
mean(a$sulfate, na.rm=T)
sum(is.na(a$sulfate))
sum(is.na(a$sulfate)) - 1461
source('pollutantmean.R')
pollutantmean('specdata', 'sulfate', 1)
source('pollutantmean.R')
pollutantmean('specdata', 'sulfate', 1)
pollutantmean('specdata', 'sulfate', 1:10)
pollutantmean('specdata', 'sulfate', 3:10)
pollutantmean('specdata', 'nitrate', 70:72)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
submit()
submit()
submit()
source('submitscript1.R')
submit(manual=TRUE)
pollutantmean('specdata', 'nitrate')
source('pollutantmean.R')
pollutantmean('specdata', 'nitrate') -> aa
str(aa)
source('pollutantmean.R')
pollutantmean('specdata', 'nitrate') -> aa
str(aa)
sum(complete.cases(aa))
sum(is.na(aa$nobs))
sum(is.nan(aa$nobs))
sum(is.na(aa$mean))
NA/NA
sum(is.nan(aa$mean))
which(is.na(aa$mean))
which(is.na(aa$mean)) -> iidd
pollutantmean('specdata', 'nitrate', iidd) -> bb
bb
mean(NA, na.rm=T)
pollutantmean('specdata', 'nitrate') -> bb
source('pollutantmean.R')
source('pollutantmean.R')
pollutantmean('specdata', 'nitrate') -> bb
bb
submit()
length
source('complete.R')
complete('specdata', 1)
source('complete.R')
complete('specdata', 1)
source('complete.R')
complete('specdata', 1)
ls()
str(a)
complete.cases(a)
sum(complete.cases(a))
source('complete.R')
complete('specdata', 1)
complete("specdata", c(2, 4, 8, 10, 12))
submit()
submit()
submit()
aa
aa <- c(4, 5)
append(aa, 6)
append
result <- numeric(0)
result
?dir
list.files()
list.files('specdata/')
list.files('specdata/') -> bbb
strsplit(bbb)
strsplit(bbb, split='.')
strsplit(bbb, split='.', fixed=TRUE)
?strsplit
strsplit('hello.world', split='.')
strsplit('hello.world', split='.', fixed=TRUE)
strsplit('hello.world', split='.', fixed=TRUE)[[1]][1]
getmonitorids <- function(directory){
mon.list <- list.files(directory)
for (i in 1:length(mon.list)){
mon.list[i] <- strsplit(mon.list[i], split='.', fixed=TRUE)[[1]][1]
}
as.integer(mon.list)
}
getmonitorids('specdata')
complete
cor(a$sulfate, a$nitrate)
cor(a$sulfate, a$nitrate, na.rm=T)
str(cor)
?cor
cor(a$sulfate, a$nitrate, use='pairwise.complete.obs')
source('corr.R')
cr <- corr("specdata", 150)
head(cr)
summary(cr)
cr <- corr("specdata", 5000)
summary(cr)
cr <- corr("specdata")
summary(cr)
length(cr)
submit()
submit()
submit()
